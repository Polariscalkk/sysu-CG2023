#include "myglwidget.h"

MyGLWidget::~MyGLWidget() { }

// resize window
void MyGLWidget::resizeGL(int w, int h) {
    if (h == 0) h = 1;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, static_cast<double>(w) / static_cast<double>(h), 0.1, 100.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

const GLfloat MyGLWidget::COLORS[][3] = {   // particle colors
    {1.0f, 0.5f, 0.5f}, { 1.0f, 0.75f, 0.5f }, { 1.0f, 1.0f, 0.5f },
    {0.75f, 1.0f, 0.5f}, { 0.5f, 1.0f, 0.5f }, { 0.5f, 1.0f, 0.75f },
    {0.5f, 1.0f, 1.0f}, { 0.5f, 0.75f, 1.0f }, { 0.5f, 0.5f, 1.0f },
    {0.75f, 0.5f, 1.0f}, { 1.0f, 0.5f, 1.0f }, { 1.0f, 0.5f, 0.75f }
};


MyGLWidget::MyGLWidget(QWidget* parent) :
    QGLWidget(parent) {
    m_FileName = "./fireworkPicture.png";   // load particle texture path
    m_Rainbow = false;
    m_Color = 0;
    m_Slowdown = 2.0f;
    m_xSpeed = 0.0f;
    m_ySpeed = 0.0f;
    m_Deep = -40.0f;

    // activate the particle trigger
    m_Particles[MAX_PARTICLES].active = true;
    m_Particles[MAX_PARTICLES].life = 1.0f;
    m_Particles[MAX_PARTICLES].fade = float(rand() % 100) / 1000.0f + 0.001;

    // trigger: set random color
    m_Particles[MAX_PARTICLES].r = COLORS[m_Rainbow ? rand() % 12 : m_Color][0];
    m_Particles[MAX_PARTICLES].g = COLORS[m_Rainbow ? rand() % 12 : m_Color][1];
    m_Particles[MAX_PARTICLES].b = COLORS[m_Rainbow ? rand() % 12 : m_Color][2];

    // trigger: initial position
    m_Particles[MAX_PARTICLES].x = 0.0f;
    m_Particles[MAX_PARTICLES].y = -20.0f;
    m_Particles[MAX_PARTICLES].z = 0.0f;

    // trigger: random velocity
    m_Particles[MAX_PARTICLES].xi = float((rand() % 50) - 26.0f) * 2.0f;
    m_Particles[MAX_PARTICLES].yi = float((rand() % 50) + 25.0f) * 10.0f;
    m_Particles[MAX_PARTICLES].zi = float((rand() % 50) - 25.0f) * 2.0f;

    // trigger: set gravity
    m_Particles[MAX_PARTICLES].xg = 0.0f;
    m_Particles[MAX_PARTICLES].yg = -0.8f;
    m_Particles[MAX_PARTICLES].zg = 0.0f;

    // initialize all particle generated by the trigger
    for (int i = 0; i < MAX_PARTICLES; i++) {
        m_Particles[i].active = false;
        m_Particles[i].life = 1.0f;
        m_Particles[i].fade = float(rand() % 100) / 1000.0f + 0.001;

        // particle: color
        m_Particles[i].r = COLORS[m_Rainbow ? rand() % 12 : m_Color][0];
        m_Particles[i].g = COLORS[m_Rainbow ? rand() % 12 : m_Color][1];
        m_Particles[i].b = COLORS[m_Rainbow ? rand() % 12 : m_Color][2];

        // particle: gravity
        m_Particles[i].xg = -0.1f;
        m_Particles[i].yg = -0.1f;
        m_Particles[i].zg = -0.1f;
    }

    // timer
    QTimer * timer = new QTimer(this);
    connect(timer, SIGNAL(timeout()), this, SLOT(updateGL()));
    timer->start(10); // 10ms a cycle
}

void MyGLWidget::initializeGL() {
    m_Texture = bindTexture(QPixmap(m_FileName));       // load texture
    glEnable(GL_TEXTURE_2D);                            // enable texture mapping
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);               // background color: black
    glShadeModel(GL_SMOOTH);                            // enable shadow smoothing
    glClearDepth(1.0);                                  // set deep cache
    glDisable(GL_DEPTH_TEST);                           // disable deep testing
    glEnable(GL_BLEND);                                 // enable fusion
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);                  // set fusion factor
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  // perspective correction
    glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
}

void MyGLWidget::paintGL() {
    showFullScreen();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    glBindTexture(GL_TEXTURE_2D, m_Texture);

    // update the firework if is active
    if (m_Particles[MAX_PARTICLES].active) {
        // update postion and velocity
        m_Particles[MAX_PARTICLES].x += m_Particles[MAX_PARTICLES].xi / (m_Slowdown * 1000);
        m_Particles[MAX_PARTICLES].y += m_Particles[MAX_PARTICLES].yi / (m_Slowdown * 1000);
        m_Particles[MAX_PARTICLES].z += m_Particles[MAX_PARTICLES].zi / (m_Slowdown * 1000);

        float x = m_Particles[MAX_PARTICLES].x;
        float y = m_Particles[MAX_PARTICLES].y;
        float z = m_Particles[MAX_PARTICLES].z + m_Deep;

        // set color
        glColor4f(
            m_Particles[MAX_PARTICLES].r, 
            m_Particles[MAX_PARTICLES].g, 
            m_Particles[MAX_PARTICLES].b, 
            m_Particles[MAX_PARTICLES].life
        );

        // draw triangle strip
        glBegin(GL_TRIANGLE_STRIP);
        glTexCoord2d(1, 1); glVertex3f(x + 0.5f, y + 0.5f, z);
        glTexCoord2d(0, 1); glVertex3f(x - 0.5f, y + 0.5f, z);
        glTexCoord2d(1, 0); glVertex3f(x + 0.5f, y - 0.5f, z);
        glTexCoord2d(0, 0); glVertex3f(x - 0.5f, y - 0.5f, z);
        glEnd();

        // trigger: explosion
        if (m_Particles[MAX_PARTICLES].y > 10.0f && m_Particles[MAX_PARTICLES].life > 0) {
            m_Particles[MAX_PARTICLES].xi = 0.0f;
            m_Particles[MAX_PARTICLES].yi = 0.0f;
            m_Particles[MAX_PARTICLES].zi = 0.0f;

            // record the explosion postion
            float n_x = m_Particles[MAX_PARTICLES].x;
            float n_y = m_Particles[MAX_PARTICLES].y;
            float n_z = m_Particles[MAX_PARTICLES].z;

            // decrease particle lifespan
            m_Particles[MAX_PARTICLES].life -= m_Particles[MAX_PARTICLES].fade;

            // update all particles
            for (int i = 0; i < MAX_PARTICLES; i++) {
                if (!m_Particles[i].active) {
                    m_Particles[i].active = true;
                    m_Particles[i].life = 1.0f;

                    // set postion: inherit from the trigger's explosion position
                    m_Particles[i].x = n_x;
                    m_Particles[i].y = n_y;
                    m_Particles[i].z = n_z;

                    // set color
                    m_Particles[i].r = COLORS[m_Rainbow ? rand() % 12 : m_Color][0];
                    m_Particles[i].g = COLORS[m_Rainbow ? rand() % 12 : m_Color][1];
                    m_Particles[i].b = COLORS[m_Rainbow ? rand() % 12 : m_Color][2];

                    // set random velocity
                    m_Particles[i].xi = float((rand() % 50) - 26.0f) * 10.0f;
                    m_Particles[i].yi = float((rand() % 50) - 25.0f) * 10.0f;
                    m_Particles[i].zi = float((rand() % 50) - 25.0f) * 10.0f;
                }
            }
        }
        // if a firework end firing, generate another firework(trigger).
        else if (m_Particles[MAX_PARTICLES].y > 10.0f && m_Particles[MAX_PARTICLES].life <= 0) {
            m_Particles[MAX_PARTICLES].active = true;
            m_Particles[MAX_PARTICLES].life = 1.0f;
            m_Particles[MAX_PARTICLES].fade = float(rand() % 100) / 1000.0f + 0.001;

            m_Particles[MAX_PARTICLES].r = COLORS[m_Rainbow ? rand() % 12 : m_Color][0];
            m_Particles[MAX_PARTICLES].g = COLORS[m_Rainbow ? rand() % 12 : m_Color][1];
            m_Particles[MAX_PARTICLES].b = COLORS[m_Rainbow ? rand() % 12 : m_Color][2];

            m_Particles[MAX_PARTICLES].x = 0.0f;
            m_Particles[MAX_PARTICLES].y = -20.0f;
            m_Particles[MAX_PARTICLES].z = 0.0f;

            m_Particles[MAX_PARTICLES].xi = float((rand() % 50) - 26.0f) * 2.0f;
            m_Particles[MAX_PARTICLES].yi = float((rand() % 50) + 25.0f) * 10.0f;
            m_Particles[MAX_PARTICLES].zi = float((rand() % 50) - 25.0f) * 2.0f;

            m_Particles[MAX_PARTICLES].xg = 0.0f;
            m_Particles[MAX_PARTICLES].yg = -0.8f;
            m_Particles[MAX_PARTICLES].zg = 0.0f;
        }

        // update all particles.
        for (int i = 0; i < MAX_PARTICLES; i++) {
            if (m_Particles[i].active) {
                m_Particles[i].x += m_Particles[i].xi / (m_Slowdown * 1000);
                m_Particles[i].y += m_Particles[i].yi / (m_Slowdown * 1000);
                m_Particles[i].z += m_Particles[i].zi / (m_Slowdown * 1000);

                float x = m_Particles[i].x;
                float y = m_Particles[i].y;
                float z = m_Particles[i].z + m_Deep;

                glColor4f(
                    m_Particles[i].r, 
                    m_Particles[i].g, 
                    m_Particles[i].b, 
                    m_Particles[i].life
                );

                glBegin(GL_TRIANGLE_STRIP);
                glTexCoord2d(1, 1); glVertex3f(x + 0.5f, y + 0.5f, z);
                glTexCoord2d(0, 1); glVertex3f(x - 0.5f, y + 0.5f, z);
                glTexCoord2d(1, 0); glVertex3f(x + 0.5f, y - 0.5f, z);
                glTexCoord2d(0, 0); glVertex3f(x - 0.5f, y - 0.5f, z);
                glEnd();

                // decrease particle lifespan.
                m_Particles[i].life -= m_Particles[i].fade;
                if (m_Particles[i].life < 0.0f) {
                    m_Particles[i].active = false;
                }
            }
        }
    }
}

void MyGLWidget::keyPressEvent(QKeyEvent* e) {
    switch (e->key()) {
        case Qt::Key_Escape:        // exit the program
            close();
            break;
        case Qt::Key_PageUp:        // get close to object
            m_Deep += 0.5f;
            break;
        case Qt::Key_PageDown:      // get away from object
            m_Deep -= 0.5f;
            break;
        case Qt::Key_Return:        // switch to rainbow mode
            m_Rainbow = !m_Rainbow;
            break;
        case Qt::Key_Space:         // switch firework's color
            m_Rainbow = false;
            m_Color++;
            if (m_Color > 11) {
                m_Color = 0;
            }
            break;
        case Qt::Key_Up:            // increase y-axis velocity
            if (m_ySpeed < 400.0f) {
                m_ySpeed += 5.0f;
            }
            break;
        case Qt::Key_Down:          // decrease y-axis velocity
            if (m_ySpeed > -400.0f) {
                m_ySpeed -= 5.0f;
            }
            break;
        case Qt::Key_Right:         // increase x-axis velocity
            if (m_xSpeed < 400.0f) {
                m_xSpeed += 5.0f;
            }
            break;
        case Qt::Key_Left:          // decrease x-axis velocity
            if (m_xSpeed > -400.0f) {
                m_xSpeed -= 5.0f;
            }
            break;
    }
}